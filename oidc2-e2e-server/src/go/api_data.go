/*
 * Endpoint for establishing and maintaining an encrypted client-server session
 *
 * This endpoint establishes an end-to-end encrypted client-server session after authenticating the client with its Id Certification Token (Client_ICT). After the successful exchange of DH parameters, the client can communicate with the server, upload, download or delete files on the server with all communication being encrypted on application layer.
 *
 * API version: 0.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdh"
	"crypto/ecdsa"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"errors"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"golang.org/x/crypto/hkdf"
)

func DataEndpointHandler(w http.ResponseWriter, r *http.Request, endpoint, method string) (http.ResponseWriter, error) {
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	origin := r.Header.Get("Origin")
	w.Header().Set("Access-Control-Allow-Origin", origin)

	// In case of ratchet mode we need to remember the mac secret to sign the message later
	var prevMacSecret []byte

	var clientPublicDhMac *ecdh.PublicKey
	var clientPublicDhEnc *ecdh.PublicKey

	var file []byte // for get /data request

	// Extract headers and body of http request
	var sessionTokenBase64Enc string = r.Header.Get("x-e2e-session")
	var contentType string = r.Header.Get("content-type")
	var clientPublicDhMacJwk string = r.Header.Get("x-publicKeyMac")
	var clientPublicDhEncJwk string = r.Header.Get("x-publicKeyEnc")
	var signatureBase64 string = r.Header.Get("Signature")
	var body string
	var err error

	if endpoint == "/data" && method != "get" {
		body, err = ReadRequestBody(r)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusBadRequest)
			return w, err
		}
	} else {
		body = r.Header.Get("x-filename") // enrcypted name of requested file
	}

	// Verify sessionToken and extract parameters upon success
	macSecret, encSecret, dh_s_mac, dh_s_enc, mode, kid, err := handleSessionToken(sessionTokenBase64Enc)
	if err != nil {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusBadRequest)
		return w, err
	}

	// verify HTTP MAC signature using the HKDF derived key from macSecret
	hmacKey, err := hkdfDeriveKey(macSecret)
	if err != nil {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusBadRequest)
		return w, err
	}
	if !verifyHttpSig(sessionTokenBase64Enc,
		clientPublicDhMacJwk,
		clientPublicDhEncJwk,
		contentType,
		method,
		endpoint,
		signatureBase64,
		body,
		hmacKey) {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusForbidden)
		return w, err
	}

	// Ratchet mode: Calculate current new DH encryption/MAC Secret (blue)
	if mode == "ratchet" {
		// parse DH_C+
		clientPublicDhMac, err = getClientDh(clientPublicDhMacJwk)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusBadRequest)
			return w, err
		}

		clientPublicDhEnc, err = getClientDh(clientPublicDhEncJwk)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusBadRequest)
			return w, err
		}

		// calculate DH secrets (enc and MAC)
		dh_s_mac_ecdh, err := dh_s_mac.ECDH()
		macSecret, err = makeDHSecret(dh_s_mac_ecdh, clientPublicDhMac)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}

		dh_s_enc_ecdh, err := dh_s_enc.ECDH()
		encSecret, err = makeDHSecret(dh_s_enc_ecdh, clientPublicDhEnc)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}
	}
	if endpoint == "/data" {
		if method == "delete" {
			// Decrypt filename in http message body using encSecret and delete it
			err = handleDeleteRequestBody(body, encSecret)
			if err != nil {
				log.Printf(err.Error())
				w.WriteHeader(http.StatusBadRequest)
				return w, err
			}
		} else if method == "get" {
			// Decrypt filename in http message body using encSecret and read it into file
			file, err = getFile(body, encSecret)
			if err != nil {
				log.Printf(err.Error())
				w.WriteHeader(http.StatusBadRequest)
				return w, err
			}
		} else if method == "post" {
			// Decrypt and save http message body using encSecret
			err = handlePostRequestBody(body, encSecret)
			if err != nil {
				log.Printf(err.Error())
				w.WriteHeader(http.StatusBadRequest)
				return w, err
			}
		}
	}

	// Ratchet mode: Generate new iteration DH parameters (orange)
	if mode == "ratchet" {
		// Generate next iteration DH_S^+- (for MAC)
		dh_s_mac, err = genDhKey()
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}
		// Generate next iteration DH_S^+- (for enc)
		dh_s_enc, err = genDhKey()
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}

		prevMacSecret = macSecret // Remember previous macSecret (blue)
		// Calculate DH secrets
		dh_s_mac_ecdh, _ := dh_s_mac.ECDH()
		dh_s_enc_ecdh, _ := dh_s_enc.ECDH()
		macSecret, err = makeDHSecret(dh_s_mac_ecdh, clientPublicDhMac)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}
		encSecret, err = makeDHSecret(dh_s_enc_ecdh, clientPublicDhEnc)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}
	}

	// Create new sessionToken
	sessionToken, exp, err := genSessionToken(macSecret, encSecret, dh_s_mac, dh_s_enc, mode, kid)
	if err != nil {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return w, err
	}
	// Encrypt sessionToken using encSecret
	/*sessionToken, err = encryptString(encSecret, sessionToken)
	if err != nil {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return w, err
	}*/

	if endpoint == "/data" && method == "get" {
		// encrypt file using encSecret (base64 encoded result will be the body of http GET response)
		body, err = encryptString(encSecret, string(file))
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}
	}

	// Generate JWK from server public DH params
	dhMacJwk, err := jwkStringFromPublicKey(&dh_s_mac.PublicKey)
	if err != nil {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return w, err
	}
	dhEncJwk, err := jwkStringFromPublicKey(&dh_s_enc.PublicKey)
	if err != nil {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return w, err
	}

	// Set corresponding headers in HTTP response
	w.Header().Set("x-e2e-session", sessionToken)
	w.Header().Set("x-publickeymac", dhMacJwk)
	w.Header().Set("x-publickeyenc", dhEncJwk)
	w.Header().Set("x-exp", strconv.Itoa(exp))

	// Create HTTP message signature (MAC)
	var signature string
	if mode == "ratchet" { // Ratchet mode. Use old MAC secret
		signature, err = genSignatureHeader(prevMacSecret, w.Header().Get("x-e2e-session"), w.Header().Get("x-publickeymac"), w.Header().Get("x-publickeyenc"), w.Header().Get("x-exp"), body)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}
	} else { // TLS mode. MAC secret didn't change
		signature, err = genSignatureHeader(macSecret, w.Header().Get("x-e2e-session"), w.Header().Get("x-publickeymac"), w.Header().Get("x-publickeyenc"), w.Header().Get("x-exp"), body)
		if err != nil {
			log.Printf(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			return w, err
		}
	}
	w.Header().Set("signature", signature)
	w.Header().Set("access-control-expose-headers", "status, x-e2e-session, x-publickeymac, x-publickeyenc, x-exp, signature")
	w.WriteHeader(http.StatusOK)
	io.WriteString(w, body)
	return w, nil
}

func handleDeleteRequestBody(body string, secret []byte) error {
	rawCipher, err := base64.StdEncoding.DecodeString(body)
	if err != nil {
		return err
	}
	// extract iv
	iv := rawCipher[:12]
	ciphertext := rawCipher[12:]

	// decrypt AES-GCM
	block, err := aes.NewCipher(secret)
	if err != nil {
		return err
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}
	plainbytes, err := aesgcm.Open(nil, iv, ciphertext, nil)
	if err != nil {
		return err
	}
	filename := string(plainbytes)
	// Delete file
	err = os.Remove(filename)
	if err != nil {
		return err
	}

	return nil
}

// Handle DELETE "/data" request
func DataDelete(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received data DELETE request")
	w, _ = DataEndpointHandler(w, r, "/data", "delete")
}

// decrypt filename and read it
func getFile(filename string, secret []byte) ([]byte, error) {
	rawCipher, err := base64.StdEncoding.DecodeString(filename)
	if err != nil {
		return nil, err
	}
	// extract iv
	iv := rawCipher[:12]
	ciphertext := rawCipher[12:]

	// decrypt AES-GCM
	block, err := aes.NewCipher(secret)
	if err != nil {
		return nil, err
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}
	plainbytes, err := aesgcm.Open(nil, iv, ciphertext, nil)
	if err != nil {
		return nil, err
	}
	filename = string(plainbytes)
	// Read file
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	return file, nil
}

// Handle GET "/data" request
func DataGet(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received data GET request")
	w, _ = DataEndpointHandler(w, r, "/data", "get")
}

// verify sessionToken. Upon success, extract and return macSecret, encSecret, dh_s_mac, dh_s_enc, mode, kid
func handleSessionToken(sessionTokenBase64Enc string) ([]byte, []byte, *ecdsa.PrivateKey, *ecdsa.PrivateKey, string, string, error) {
	// decrypt sessionToken using K_S
	cipherBytes, err := base64.StdEncoding.DecodeString(sessionTokenBase64Enc)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	nonce := cipherBytes[:12]
	ciphertext := cipherBytes[12:]
	block, err := aes.NewCipher(K_S)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	plainbytes, err := aesgcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	log.Printf("Decrypted sessionToken: %s", string(plainbytes))
	plaintext := string(plainbytes)

	// verify sessionToken HS256 signature using K_S
	sessionTokenHeaderEnc, sessionTokenBodyEnc, sessionTokenSignEnc, err := splitJWT(plaintext)
	messageMAC, err := base64.RawURLEncoding.DecodeString(sessionTokenSignEnc)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	mac := hmac.New(sha256.New, K_S)
	mac.Write([]byte(sessionTokenHeaderEnc + "." + sessionTokenBodyEnc))
	expectedMAC := mac.Sum(nil)
	if !hmac.Equal(messageMAC, expectedMAC) {
		return nil, nil, nil, nil, "", "", errors.New("SessionToken signature could not be verified")
	}

	// Make sessionToken readable
	sessionTokenBodyDec, err := base64.RawStdEncoding.DecodeString(sessionTokenBodyEnc)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	sessionTokenBodyString := string(sessionTokenBodyDec)
	log.Printf("sessionTokenBodyString: %s", sessionTokenBodyString)
	var sessionTokenData map[string]interface{}
	err = json.Unmarshal([]byte(sessionTokenBodyString), &sessionTokenData)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	// Check if sessionToken is expired
	exp := int(sessionTokenData["exp"].(float64))
	if int(time.Now().Unix())-exp > 60 {
		return nil, nil, nil, nil, "", "", errors.New("SessionToken expired")
	}

	// Extract all relevant information from sessionToken
	macSecretBase64 := sessionTokenData["macSecret"].(string)
	encSecretBase64 := sessionTokenData["encSecret"].(string)
	dhSMacBase64 := sessionTokenData["dhSMac"].(string)
	dhSEncBase64 := sessionTokenData["dhSEnc"].(string)
	mode := sessionTokenData["mode"].(string)
	kid := sessionTokenData["kid"].(string)

	// Convert information into corresponding format
	macSecret, err := base64.StdEncoding.DecodeString(macSecretBase64)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	encSecret, err := base64.StdEncoding.DecodeString(encSecretBase64)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}

	dhSMacBytes, err := base64.StdEncoding.DecodeString(dhSMacBase64)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	dhSEncBytes, err := base64.StdEncoding.DecodeString(dhSEncBase64)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}

	dhSMac, err := x509.ParseECPrivateKey(dhSMacBytes)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}
	dhSEnc, err := x509.ParseECPrivateKey(dhSEncBytes)
	if err != nil {
		return nil, nil, nil, nil, "", "", err
	}

	return macSecret, encSecret, dhSMac, dhSEnc, mode, kid, nil
}

// Derive MAC key from macSecret using HKDF
func hkdfDeriveKey(macSecret []byte) ([]byte, error) {
	hash := sha256.New
	hkdf := hkdf.New(hash, macSecret, nil, nil)
	// TODO: klären warum 64 byte langer key (so wird er von SubtleCrypto erzeugt) und nicht 32 byte
	// Es wird ja SHA-256 verwendet?
	key := make([]byte, 64)
	_, err := io.ReadFull(hkdf, key)
	if err != nil {
		return nil, err
	}
	return key, nil
}

func verifyHttpSig(sessionTokenBase64Enc,
	clientPublicDhMacJwk,
	clientPublicDhEncJwk,
	contentType,
	method,
	endpoint,
	signatureBase64,
	body string,
	key []byte) bool {
	// Create signature input
	var input string = "(request-target): " + method + " " + endpoint + "\n"
	input = input + "host: " + host + "\n"
	input = input + "x-e2e-session: " + sessionTokenBase64Enc + "\n"
	input = input + "content-type: " + contentType + "\n"
	input = input + "x-publickeymac: " + clientPublicDhMacJwk + "\n"
	input = input + "x-publickeyenc: " + clientPublicDhEncJwk + "\n"
	input = input + "body: " + body

	// calculate HMAC over signature input and compare to received HMAC
	receivedMAC, err := base64.StdEncoding.DecodeString(signatureBase64)
	if err != nil {
		log.Printf(err.Error())
		return false
	}
	mac := hmac.New(sha256.New, key)
	mac.Write([]byte(input))
	expectedMAC := mac.Sum(nil)
	if !hmac.Equal(receivedMAC, expectedMAC) {
		log.Printf("HTTP message signature could not be verified")
		return false
	}

	return true
}

// Decrypt body using DH enc secret and save decrypted file
func handlePostRequestBody(body string, secret []byte) error {
	encFile, err := base64.StdEncoding.DecodeString(body)
	if err != nil {
		return err
	}
	// extract iv
	iv := encFile[:12]
	ciphertext := encFile[12:]

	// decrypt AES-GCM
	block, err := aes.NewCipher(secret)
	if err != nil {
		return err
	}
	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}
	plainbytes, err := aesgcm.Open(nil, iv, ciphertext, nil)
	if err != nil {
		return err
	}
	plainstring := string(plainbytes)
	slices := strings.Split(plainstring, ".")
	filenameBytes, err := base64.StdEncoding.DecodeString(slices[0])
	filename := string(filenameBytes)
	content, err := base64.StdEncoding.DecodeString(slices[1])
	log.Printf("Received file: %s", filename)

	// Save file
	err = os.WriteFile(filename, content, 0666)
	if err != nil {
		return err
	}

	return nil

}

// encrypt string using encSecret (AES-GCM-256 key)
// return result as Base64 string
func encryptString(key []byte, plaintext string) (string, error) {
	/* DEBUGGING
	log.Printf("Encryption key: %s", base64.StdEncoding.EncodeToString(key))	*/

	block, err := aes.NewCipher(key)
	if err != nil {
		log.Printf(err.Error())
		return "", err
	}
	nonce := make([]byte, 12)
	_, err = io.ReadFull(rand.Reader, nonce)
	if err != nil {
		log.Printf(err.Error())
		return "", err
	}

	aesgcm, err := cipher.NewGCM(block)
	if err != nil {
		log.Printf(err.Error())
		return "", err
	}
	ciphertext := aesgcm.Seal(nil, nonce, []byte(plaintext), nil)

	// prepend 12 byte nonce to ciphertext
	ciphertext = append(nonce, ciphertext...)

	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Generate MAC using secret over HTTP response parameters
func genSignatureHeader(macSecret []byte, authorization, publickeymac, publickeyenc, exp, body string) (string, error) {
	// Calculate HMAC key using HKDF derivation
	hmacKey, err := hkdfDeriveKey(macSecret)
	if err != nil {
		return "", err
	}

	var input string = "content-type: " + "text/plain; charset=utf-8" + "\n"
	input = input + "x-e2e-session: " + authorization + "\n"
	input = input + "x-publickeymac: " + publickeymac + "\n"
	input = input + "x-publickeyenc: " + publickeyenc + "\n"
	input = input + "x-exp: " + exp + "\n"
	input = input + "body: " + body + "\n"

	/*// DEBUGGING
	log.Printf("Signature input: %s", base64.StdEncoding.EncodeToString([]byte(input)))
	log.Printf("Key: %s", base64.StdEncoding.EncodeToString(hmacKey))*/

	// calculate MAC value
	mac := hmac.New(sha256.New, hmacKey)
	mac.Write([]byte(input))
	calculatedMAC := mac.Sum(nil)

	base64Mac := base64.StdEncoding.EncodeToString(calculatedMAC)

	return base64Mac, nil
}

// Handle POST "/data" request
func PostFile(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received data PostFile request")
	w, _ = DataEndpointHandler(w, r, "/data", "post")
}

// Handle OPTIONS request
func DataOptions(w http.ResponseWriter, r *http.Request) {
	origin := r.Header.Get("Origin")
	log.Print("origin: " + origin)
	if origin != "" {
		w.Header().Set("Access-Control-Allow-Origin", origin)
	}
	w.Header().Set("Access-Control-Allow-Methods", "POST, GET, DELETE, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "x-e2e-session, x-publickeyenc, x-publickeymac, signature, x-filename")
	w.WriteHeader(http.StatusNoContent)

	return
}
