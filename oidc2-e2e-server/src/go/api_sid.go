/*
 * Endpoint for establishing and maintaining an encrypted client-server session
 *
 * This endpoint establishes an end-to-end encrypted client-server session after authenticating the client with its Id Certification Token (Client_ICT). After the successful exchange of DH parameters, the client can communicate with the server, upload, download or delete files on the server with all communication being encrypted on application layer.
 *
 * API version: 0.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"crypto"
	"crypto/ecdh"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/sha512"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"errors"
	"io"
	"log"
	"math/big"
	"net/http"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/lestrrat-go/jwx/jwk"
)

// The actual SessionRequestToken received from client
type SessionRequestToken struct {
	Ict   string `json:"ict"`
	DhMac string `json:"dhMac"`
	DhEnc string `json:"dhEnc"`
	State string `json:"state"`
	Mode  string `json:"mode"`
}

// Claims for the JWk in the workload identity token
type myJWKClaims struct {
	KeyType       string `json:"kty"`
	Usage         string `json:"use"`
	KeyID         string `json:"kid"`
	Algorithm     string `json:"alg"`
	KeyOperations string `json:"key_ops"`
	Exponent      string `json:"e"`
	Modulus       string `json:"n"`
}

// Symmetric AES-256 key K_S (known amongst all server instances)
// TODO: Caution! It is not considered that not more than 2^32 nonces should be used with the same key
var K_S []byte
var nonceCounter uint32 = 0

// Asymmetric RSA private key for server certificate
var K_S_RSA *rsa.PrivateKey

// PKI's asymmetric RSA private key
var K_PKI *rsa.PrivateKey

// String determining current host location
var host string = "http://localhost:4040"

// Init K_S
func Init() {
	// Generate symmetric server key K_S
	len := 32 // AES-256
	K_S = make([]byte, len)
	_, err := rand.Read(K_S)
	if err != nil {
		log.Println(err.Error())
		return
	}

	// Generate asymmetric RSA private key K_S_RSA
	bits := 4096
	K_S_RSA, err = rsa.GenerateKey(rand.Reader, bits)
	if err != nil {
		log.Println(err.Error())
		return
	}

	// Generate PKI's asymmetric RSA private key K_PKI
	K_PKI, err = rsa.GenerateKey(rand.Reader, bits)
	if err != nil {
		log.Println(err.Error())
		return
	}

	return
}

func LogAndSendError(w http.ResponseWriter, statusCode int, status string, description string, details string) {
	// Log error
	log.Print("[ERROR] " + details)

	w.WriteHeader(statusCode)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	json.NewEncoder(w).Encode(ErrorStatus{
		Code:        int32(statusCode),
		Status:      status,
		Description: description,
	})
}

// Read the body of a HTTP request
func ReadRequestBody(r *http.Request) (string, error) {
	// Read request body
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		return "", errors.New("failed to read request body: " + err.Error())
	}

	// Convert to string and return
	return string(bodyBytes), nil
}

// Read the body of a HTTP response
func ReadResponseBody(r *http.Response) (string, error) {
	// Read response body
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		return "", errors.New("failed to read /.well-known response body: " + err.Error())
	}

	// Convert to string and return
	return string(bodyBytes), nil
}

// Split a jwt into header, body, signature (all Base64 encoded)
func splitJWT(jwt string) (string, string, string, error) {
	slices := strings.Split(jwt, ".")
	if len(slices) != 3 {
		return "", "", "", errors.New("failed to parse JWT: ")
	}

	return slices[0], slices[1], slices[2], nil
}

// Get OP's public key from its .well-known endpoint
// Return public key and corresponding kid
func requestOpPublicKey(ictHeaderEnc string, ictBodyEnc string) (*rsa.PublicKey, string, error) {
	// Extract OP kid from ICT header
	ictHeaderDec, err := base64.RawStdEncoding.DecodeString(ictHeaderEnc)
	if err != nil {
		log.Printf("Could not convert Base64 ICT header")
		log.Printf(err.Error())
		return nil, "", err
	}
	ictHeaderString := string(ictHeaderDec)
	var ictHeaderData map[string]interface{}
	err = json.Unmarshal([]byte(ictHeaderString), &ictHeaderData)
	if err != nil {
		log.Printf(err.Error())
		return nil, "", err
	}
	kid := ictHeaderData["kid"].(string)
	log.Printf("ICT kid: %s", kid)

	// Extract iss data from ICT body
	ictBodyDec, err := base64.RawStdEncoding.DecodeString(ictBodyEnc)
	if err != nil {
		log.Printf("Could not convert Base64 ICT body")
		return nil, "", err
	}
	ictBodyString := string(ictBodyDec)
	var ictBodyData map[string]interface{}
	err = json.Unmarshal([]byte(ictBodyString), &ictBodyData)
	if err != nil {
		log.Printf(err.Error())
		return nil, "", err
	}
	iss := ictBodyData["iss"].(string)
	log.Printf("ICT iss: %s", iss)

	/*
		/////////////////////////////////////////////
		// This is a dirty workaround for the current testing playground I'm on
		if iss == "http://op.localhost/realms/ict" {
			iss = "http://localhost:8080/realms/ict"
		}
		/////////////////////////////////////////////
	*/

	// Get jwks_uri
	res, err := http.Get(iss + "/.well-known/openid-configuration")
	if err != nil {
		log.Printf(err.Error())
		return nil, "", err
	}
	wellKnownBody, err := ReadResponseBody(res)
	if err != nil {
		log.Printf(err.Error())
		return nil, "", err
	}
	var payload map[string]interface{}
	err = json.Unmarshal([]byte(wellKnownBody), &payload)
	if err != nil {
		log.Fatal("Error during Unmarshal(): ", err)
		return nil, "", err
	}
	jwks_uri := payload["jwks_uri"].(string)
	log.Printf("jwks_uri: %s", jwks_uri)

	set, err := jwk.Fetch(context.Background(), jwks_uri)
	if err != nil {
		return nil, "", err
	}
	key, found := set.LookupKeyID(kid)
	if !found {
		return nil, "", errors.New("Could not find key in provided jwks")
	}
	var rsaKey rsa.PublicKey
	key.Raw(&rsaKey)
	return &rsaKey, kid, nil
}

// Validate ICT using OP's public key
// NOTE: This only works for RSA-256 key!!
// Return true and the corresponding kid when signature is valid
func validateIct(ict string) (bool, string) {
	// Split ICT into parts
	ictHeaderEnc, ictBodyEnc, ictSignEnc, err := splitJWT(ict)
	if err != nil {
		log.Printf("Could not parse ICT in sessionRequestJWT")
		return false, ""
	}
	// Get OP's public key
	publicKey, kid, err := requestOpPublicKey(ictHeaderEnc, ictBodyEnc)
	if err != nil {
		log.Printf("Could not validate ICT")
		return false, ""
	}

	// Verify JWT Signature
	byteSig, err := base64.RawURLEncoding.DecodeString(ictSignEnc)
	if err != nil {
		log.Printf("Could not convert Base64 ICT signature: %s\n", err)
		return false, ""
	}

	message := []byte(ictHeaderEnc + "." + ictBodyEnc)
	h := sha256.New()
	_, err = h.Write(message)
	if err != nil {
		log.Printf("Error from SHA256: %s\n", err)
		return false, ""
	}
	d := h.Sum(nil)

	err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA256, d, byteSig)
	if err != nil {
		log.Printf("Error from verification: %s\n", err)
		return false, ""
	}

	// Check if ICT is not expired
	ictBodyDec, err := base64.RawStdEncoding.DecodeString(ictBodyEnc)
	if err != nil {
		log.Printf("Could not convert Base64 ICT body")
		return false, ""
	}
	ictBodyString := string(ictBodyDec)
	var ictBodyData map[string]interface{}
	err = json.Unmarshal([]byte(ictBodyString), &ictBodyData)
	if err != nil {
		log.Printf(err.Error())
		return false, ""
	}
	now := int(time.Now().Unix())
	if now > int(ictBodyData["exp"].(float64)) {
		return false, ""
	}

	return true, kid
}

// Extract K_C^+ from ICT
func getClientPublicKey(ict string) (*ecdsa.PublicKey, error) {
	// Split ICT into parts
	_, ictBodyEnc, _, err := splitJWT(ict)
	if err != nil {
		log.Printf("Could not parse ICT in sessionRequestJWT")
		return nil, err
	}
	ictBodyDec, err := base64.RawStdEncoding.DecodeString(ictBodyEnc)
	if err != nil {
		log.Printf(err.Error())
		return nil, err
	}
	ictBodyString := string(ictBodyDec)
	//log.Printf("ictBodyString: %s", ictBodyString)
	var ictBodyData map[string]json.RawMessage
	err = json.Unmarshal([]byte(ictBodyString), &ictBodyData)
	if err != nil {
		log.Printf(err.Error())
		return nil, err
	}
	var ictCNFData map[string]json.RawMessage
	//log.Printf("cnfString: %s", string(ictBodyData["cnf"]))
	err = json.Unmarshal(ictBodyData["cnf"], &ictCNFData)
	if err != nil {
		log.Printf(err.Error())
		return nil, err
	}

	jwkString := string(ictCNFData["jwk"])
	//log.Printf("jwkString: %s", jwkString)
	key, err := jwk.ParseKey([]byte(jwkString))
	if err != nil {
		log.Printf(err.Error())
		return nil, err
	}
	var ecdsaKey ecdsa.PublicKey
	key.Raw(&ecdsaKey)
	return &ecdsaKey, nil
}

// Validate session request token signature using P-384 public key
// NOTE: This only works for P-384 keys!!
func validateSessReq(tokenHeaderEnc string,
	tokenBodyEnc string,
	tokenSignEnc string,
	clientPubKey *ecdsa.PublicKey) bool {
	msg := tokenHeaderEnc + "." + tokenBodyEnc
	hash := sha512.Sum384([]byte(msg))
	sig, err := base64.RawURLEncoding.DecodeString(tokenSignEnc)
	if err != nil {
		log.Printf("Could not decode base64url signature from request token")
		log.Printf(err.Error())
		return false
	}
	//length := len(sig)
	r := new(big.Int)
	s := new(big.Int)
	r.SetBytes(sig[:48])
	s.SetBytes(sig[48:])

	return ecdsa.Verify(clientPubKey, hash[:], r, s)
}

// Generate a ECDH keypair (P-256)
/* Note: for easier compatibility with jwk, we create ecdsa keys that are then
converted into ecdh keys when needed */
func genDhKey() (*ecdsa.PrivateKey, error) {
	curve := elliptic.P256()
	key, err := ecdsa.GenerateKey(curve, rand.Reader)
	if err != nil {
		return nil, err
	}
	return key, nil
}

// Create a shared secret with DH private and public key
func makeDHSecret(private *ecdh.PrivateKey, public *ecdh.PublicKey) ([]byte, error) {
	secret, err := private.ECDH(public)
	if err != nil {
		log.Printf(err.Error())
		return nil, err
	}

	return secret, nil
}

// Extract client DH public key from session request token
func getClientDh(dhKey string) (*ecdh.PublicKey, error) {
	log.Printf("DHKey: %s", dhKey)
	key, err := jwk.ParseKey([]byte(dhKey))
	if err != nil {
		return nil, err
	}
	// Must be ecdsa.PublicKey since Raw() returns ecdsa keytype on elliptic keys
	var ecdsaPublicKey ecdsa.PublicKey
	err = key.Raw(&ecdsaPublicKey)
	if err != nil {
		return nil, err
	}

	// Convert ecdsa into ecdh public key
	var ecdhPublicKey *ecdh.PublicKey
	ecdhPublicKey, err = ecdsaPublicKey.ECDH()
	if err != nil {
		return nil, err
	}

	return ecdhPublicKey, nil
}

// Create a jwk from a DH public key (P-256)
func jwkStringFromPublicKey(key *ecdsa.PublicKey) (string, error) {
	publicKeyJwk, err := jwk.New(key)
	if err != nil {
		log.Printf(err.Error())
		return "", err
	}

	publicKeyJwk.Set("key_ops", "deriveKey")

	buf, err := json.Marshal(publicKeyJwk)
	if err != nil {
		log.Printf("failed to marshal key into JSON: %s\n", err)
		return "", err
	}

	return string(buf), nil
}

// Create a new session token
// A session token is a JWT signed and encrypted by symmetric K_S
// It contains DH shared secret, DH_S^+-, issued at, expires at, kid from K_C+
// Return ecrypted session token and corresponding nonce
func genSessionToken(macSecret, encSecret []byte,
	dh_s_mac, dh_s_enc *ecdsa.PrivateKey,
	mode, kid string) (string, int, error) {
	// Convert secrets and key to base64 strings
	base64macSecret := base64.StdEncoding.EncodeToString(macSecret)
	base64encSecret := base64.StdEncoding.EncodeToString(encSecret)

	byteDhSMac, err := x509.MarshalECPrivateKey(dh_s_mac)
	if err != nil {
		log.Printf(err.Error())
		return "", 0, err
	}
	base64DhSMac := base64.StdEncoding.EncodeToString(byteDhSMac)
	byteDhSEnc, err := x509.MarshalECPrivateKey(dh_s_enc)
	if err != nil {
		log.Printf(err.Error())
		return "", 0, err
	}
	base64DhSEnc := base64.StdEncoding.EncodeToString(byteDhSEnc)

	timestamp := int(time.Now().Unix())
	exp := timestamp + 60
	sessionToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"macSecret": base64macSecret,
		"encSecret": base64encSecret,
		"dhSMac":    base64DhSMac,
		"dhSEnc":    base64DhSEnc,
		"iat":       timestamp,
		"exp":       exp,
		"mode":      mode,
		"kid":       kid,
	})

	// Generate signed token
	sessionTokenString, err := sessionToken.SignedString(K_S)
	if err != nil {
		log.Printf(err.Error())
		return "", 0, err
	}
	log.Printf("raw sessionTokenString: %s", sessionTokenString)

	// encrypt token string using K_S
	nonceCounter += 1
	if nonceCounter == 4294967295 { // TODO should take action
		log.Printf("Number of nonces exceeded. K_S should be replaced!")
		nonceCounter = 0
	}
	ciphertext, err := encryptString(K_S, sessionTokenString)
	if err != nil {
		return "", 0, err
	}

	return ciphertext, exp, nil
}

// Generate a response token JWT, signed with K_S_RSA containing all relevant data for the session
func genResponseToken(key *rsa.PrivateKey,
	ict_s,
	dhMacJwk,
	dhEncJwk,
	sessionToken,
	stateID string,
	exp int) (string, error) {
	responseToken := jwt.NewWithClaims(jwt.SigningMethodRS256, jwt.MapClaims{
		"workloadId":   ict_s,
		"dhMac":        dhMacJwk,
		"dhEnc":        dhEncJwk,
		"sessionToken": sessionToken,
		"state":        stateID,
		"exp":          exp,
	})
	// Generate signed response JWT
	responseTokenString, err := responseToken.SignedString(key)
	if err != nil {
		log.Printf(err.Error())
		return "", err
	}

	return responseTokenString, nil
}

// Generate a workload id token
func getWorkloadId(publicKey *rsa.PublicKey) string {
	iat := time.Now()
	expiration := iat.Add(time.Hour * 1)

	serverPublicKeyJwk, err := jwk.New(publicKey)
	if err != nil {
		log.Printf(err.Error())
		return ""
	}

	serverPublicKeyJwk.Set("key_ops", "verify")

	claims := jwt.MapClaims{
		"sub": "enc_demo_frontend",
		"iss": "Server RPKI",
		"iat": iat.Unix(),        // maybe without Unix?
		"exp": expiration.Unix(), // maybe without unix
		"jwk": serverPublicKeyJwk,
	}

	header := jwt.MapClaims{
		"alg": "RS512",
		"typ": "JWT",
	}

	token := jwt.NewWithClaims(jwt.SigningMethodRS512, claims)
	token.Header = header
	tokenString, err := token.SignedString(K_PKI)
	if err != nil {
		log.Printf(err.Error())
		return ""
	}
	return tokenString
}

// Generate a session token fitting to a sessionToken request and send it to the client
func GenSession(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received sid request")
	requestBody, err := ReadRequestBody(r)
	if err != nil {
		LogAndSendError(w, http.StatusBadRequest, "Bad Request", "Missing http request body", "failed to read request body: "+err.Error())
		return
	}
	// split the session request token up in its parts
	jwtHeaderEnc, jwtBodyEnc, jwtSignEnc, err := splitJWT(requestBody)
	if err != nil {
		LogAndSendError(w, http.StatusBadRequest, "Bad Request", "Could not parse JWT in requestBody", "failed to parse request body: "+err.Error())
		return
	}

	// Decode and parse sessionRequestJWT body
	jwtBodyDec, err := base64.RawURLEncoding.DecodeString(jwtBodyEnc)
	if err != nil {
		LogAndSendError(w, http.StatusBadRequest, "Bad Request", "Could not convert Base64 JWT body in requestBody", "failed to convert base64 JWT body: "+err.Error())
		return
	}
	jwtBodyString := string(jwtBodyDec)
	log.Printf("jwtBodyString: %s", jwtBodyString)
	var requestData map[string]interface{}
	err = json.Unmarshal([]byte(jwtBodyString), &requestData)
	if err != nil {
		log.Printf(err.Error())
	}

	// Validate ICT signature
	ictValid, kid := validateIct(requestData["ict"].(string))
	if !ictValid {
		log.Printf("ICT signature invalid")
		return
	}
	log.Printf("ICT signature valid")

	// Extract K_C^+ from ICT
	var clientPubKey *ecdsa.PublicKey
	clientPubKey, err = getClientPublicKey(requestData["ict"].(string))
	if clientPubKey == nil {
		log.Printf("Could not fetch K_C^+ from ICT")
		return
	}

	// Validate Session request token signature
	sessReqValid := validateSessReq(jwtHeaderEnc, jwtBodyEnc, jwtSignEnc, clientPubKey)
	if !sessReqValid {
		log.Printf("Session request token signature invalid")
		return
	}
	log.Printf("Session request token signature valid")

	// Generate DH_S^+- (for MAC)
	dh_s_mac, err := genDhKey()
	if err != nil {
		log.Printf("Error during DH key generation")
		log.Printf(err.Error())
		return
	}
	// Generate DH_S^+- (for enc)
	dh_s_enc, err := genDhKey()
	if err != nil {
		log.Printf("Error during DH key generation")
		log.Printf(err.Error())
		return
	}

	// Extract DH_C+ from session request token
	var sessReqData map[string]json.RawMessage
	err = json.Unmarshal([]byte(jwtBodyString), &sessReqData)
	if err != nil {
		log.Printf(err.Error())
		return
	}
	dh_c_mac, err := getClientDh(string(sessReqData["dhMac"]))
	if err != nil {
		log.Printf("Error while extracting dhMac from session request token")
		log.Printf(err.Error())
		return
	}
	dh_c_enc, err := getClientDh(string(sessReqData["dhEnc"]))
	if err != nil {
		log.Printf("Error while extracting dhEnc from session request token")
		log.Printf(err.Error())
		return
	}

	// Calculate DH secrets
	dh_s_mac_ecdh, _ := dh_s_mac.ECDH()
	dh_s_enc_ecdh, _ := dh_s_enc.ECDH()
	macSecret, err := makeDHSecret(dh_s_mac_ecdh, dh_c_mac)
	if err != nil {
		log.Printf("Error while calculating DH Secret")
		log.Printf(err.Error())
		return
	}
	encSecret, err := makeDHSecret(dh_s_enc_ecdh, dh_c_enc)
	if err != nil {
		log.Printf("Error while calculating encSecret")
		log.Printf(err.Error())
		return
	}

	// Convert DH_S+ into jwk string
	dhMacJwk, err := jwkStringFromPublicKey(&dh_s_mac.PublicKey)
	log.Printf("%s", dhMacJwk)
	if err != nil {
		log.Printf("Error while converting DH_S+ (MAC) to jwk")
		log.Printf(err.Error())
	}
	dhEncJwk, err := jwkStringFromPublicKey(&dh_s_enc.PublicKey)
	log.Printf("%s", dhEncJwk)
	if err != nil {
		log.Printf("Error while converting DH_S+ (enc) to jwk")
		log.Printf(err.Error())
	}

	// generate a new sessionToken
	mode := requestData["mode"].(string)
	sessionToken, exp, err := genSessionToken(macSecret, encSecret, dh_s_mac, dh_s_enc, mode, kid)
	if err != nil {
		log.Printf(err.Error())
		return
	}
	log.Printf("sessionToken: %s", sessionToken)

	// get signed certificate (ICT_S) from RPKI
	ict_s := getWorkloadId(&K_S_RSA.PublicKey)

	// assemble response body (an RSA signed JWT containing ICT_S, public DH_S (for MAC and ENC), sessionToken, stateID)
	stateID := requestData["state"].(string)
	responseToken, err := genResponseToken(K_S_RSA, ict_s, dhMacJwk, dhEncJwk, sessionToken, stateID, exp)
	log.Printf("Response token: %s", responseToken)

	origin := r.Header.Get("Origin")

	w.Header().Set("Content-Type", "text/plain; charset=UTF-8")
	w.Header().Set("Access-Control-Allow-Origin", origin)
	w.WriteHeader(http.StatusOK)
	io.WriteString(w, responseToken)
}

func GetPkiKey(w http.ResponseWriter, r *http.Request) {
	responseJwk, err := jwk.New(K_PKI.PublicKey)
	if err != nil {
		log.Printf(err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	responseJwk.Set("key_ops", "verify")

	buf, err := json.Marshal(responseJwk)
	if err != nil {
		log.Printf("failed to marshal key into JSON: %s\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	origin := r.Header.Get("Origin")
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Access-Control-Allow-Origin", origin)
	w.WriteHeader(http.StatusOK)
	io.WriteString(w, string(buf))
}
