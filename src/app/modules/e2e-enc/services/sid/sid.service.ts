/**
 * Endpoint for establishing and maintaining an encrypted client-server session
 * This endpoint establishes an end-to-end encrypted client-server session after authenticating the client with its Id Certification Token (Client_ICT). After the successful exchange of DH parameters, the client can communicate with the server, upload, download or delete files on the server with all communication being encrypted on application layer.
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../../encoder';

import { Observable }                                        from 'rxjs';

import { ErrorStatus } from '../model/errorStatus';
import { SessionResponseJwt } from '../model/sessionResponseJwt';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../../variables';
import { Configuration }                                     from '../../configuration';
import { Identity, IdentityService }                         from '../../../authentication';
import { NonceGenerators } from 'oidc-squared';
import base64url from "base64url";
import { firstValueFrom } from 'rxjs';
import { base64urlToBase64, decodeBase64url } from 'src/app/byte-array-converter';
import { Buffer } from 'buffer';

//import * as jose from 'jose';

@Injectable({
    providedIn: 'root'
  })
export class SidService {
    protected basePath = 'http://localhost:4040';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public state = "";

    /**
    * Gets identity with which to authenticate against resource server.
    */
    public get clientIdentity(): Identity {
        return this.identityService.identities[0];
    }

    /**
     * Constructs a new Sid Service Instance
     * @param httpClient HttpClient Instance.
     * @param basePath baseURL of resource server
     * @param configuration configuration parameters
     * @param identityService Identity Service instance
     */
    constructor(protected httpClient: HttpClient,
                @Optional()@Inject(BASE_PATH) basePath: string,
                @Optional() configuration: Configuration,
                private readonly identityService: IdentityService) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * Generate a new key pair K_CÂ±
     * @returns a new key pair (ECDSA, P-384)
     */
    public async genKeyPair(): Promise<CryptoKeyPair> {
        // Generate new key pair.
        const keyPair = await crypto.subtle.generateKey(
            {
            name: 'ECDSA',
            namedCurve: 'P-384',
            },
            true,
            [ 'sign', 'verify' ],
        );
        return keyPair;
    }
    
    /**
     * Generate new Diffie-Hellman parameters
     * @returns new Dh parameters that can be used to derive a key
     */
    public async genDhParams(): Promise<CryptoKeyPair> {
        const dhParams:CryptoKeyPair = await crypto.subtle.generateKey(
            {
            name: "ECDH",
            namedCurve: "P-256"
            },
            false,
            ["deriveKey"],  
        );
        return dhParams;
    }

    /**
     * Requests an Identity Certification Token.
     * @param identity Identity to request ICT for.
     * @param keyPair Asymmetric authentication key pair.
     * @param claims Identity claims to request.
     * @returns Obtained Identity Certification Token.
     */
    public async reqIct(identity: Identity, keyPair: CryptoKeyPair, claims: string[]): Promise<string> {
        return await this.identityService.requestIct(identity, keyPair, claims);
    }
    
    // Binary String to URL-Safe Base64
    private binToUrlBase64(bin: any) {
        return btoa(bin)
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+/g, '');
    }

    private uint8ToUrlBase64(uint8: any) {
        var bin = '';
        uint8.forEach(function(code: any) {
            bin += String.fromCharCode(code);
        });
        return this.binToUrlBase64(bin);
    }

    private base64urlTobase64(input: string): string {
        input.replace(/\-/g, '+').replace(/\_/g, '/');
        if (input.length % 4 == 0)
            return input;
        else if (input.length % 4 == 1)
            return input.concat("=");
        else
            return input.concat("==");
    }

    /**
     * Generates a JWT that will be sent to the server in the payload of a session request
     * @param keyPair client's asymmetric keypair
     * @param ict client's ICT for current identity
     * @param clientDHMac client's public DH parameter for message authentication
     * @param clientDHEnc client's public DH parameter for encryption
     * @param mode The mode that the client wants to use ('ratchet'|'tls')
     */
    public async genSessionJwt(keyPair: CryptoKeyPair,
                               ict: string,
                               clientDHMac: CryptoKey,
                               clientDHEnc: CryptoKey,
                               mode: string): Promise<string> {
        const dhMacJWK = await crypto.subtle.exportKey("jwk", clientDHMac);
        const dhEncJWK = await crypto.subtle.exportKey("jwk", clientDHEnc);
        this.state = NonceGenerators.uuid().generate();

        var header = {
            "alg": "ES384",
            "typ": "JWT"
        }
        var payload = {
            "ict": ict,
            "dhMac": dhMacJWK,
            "dhEnc": dhEncJWK, 
            "state": this.state,
            "mode": mode
        }

        var enc = new TextEncoder();

        const encJWT = base64url.fromBase64(btoa(JSON.stringify(header)))
                       + "."
                       + base64url.fromBase64(btoa(JSON.stringify(payload)));
        console.log('encJWT', encJWT);
        const signature: ArrayBuffer = await crypto.subtle.sign(
            {
                name: 'ECDSA',
                hash: { name: 'SHA-384' },
            },
            keyPair.privateKey,
            enc.encode(encJWT)
        );
        const base64Signature = this.uint8ToUrlBase64(new Uint8Array(signature));
        return encJWT+"."+base64Signature;
    }

    // Send POST request to /sid server endpoint with the requestJwt in body
    // Expected response is a valid sessionToken
    public requestSession(sessionRequestJwt: string): Observable<any> {
        const headers = new HttpHeaders().set('Content-Type', 'text/plain; charset=utf-8');
        return this.httpClient.post(this.basePath+'/sid', sessionRequestJwt, {headers, responseType: 'text'});
    }

    /** Verify workload identity JWT using the server PKI's public key
     * If workload identity could be verified, extract K_S+ from certificate
     * @returns serverPublicKey if signature could be verified, otherwise undefined
    */
    private async verifyWorkloadId(workloadId: string): Promise<CryptoKey|undefined> {
        let enc = new TextEncoder();
        const pkiPublicKeyJwk = await firstValueFrom(this.httpClient.get(this.basePath + "/.well-known/pki-configuration"));
        console.log(pkiPublicKeyJwk);
        const pkiPublicKey: CryptoKey = await crypto.subtle.importKey(
            "jwk", 
            pkiPublicKeyJwk,
            {
                name: "RSASSA-PKCS1-v1_5",
                hash: "SHA-512"
            },
            true,
            ["verify"]);

        var jwtParts: string[] = workloadId.split(".");
        var signatureBase64: string = base64urlToBase64(jwtParts[2]);
        var signature = Uint8Array.from(atob(signatureBase64), (c) => c.charCodeAt(0));
        var signatureInput: ArrayBuffer = enc.encode(jwtParts[0]+ "." +jwtParts[1]);

        let verified = await crypto.subtle.verify(
            "RSASSA-PKCS1-v1_5",
            pkiPublicKey,
            signature,
            signatureInput);

        if (!verified) {
            console.log("Workload Id could not be verified");
            return undefined;
        }

        console.log("Id Workload verified");
        let jwtBody = JSON.parse(atob(jwtParts[1]));
        let serverPublicKeyJwk = jwtBody["jwk"];
        console.log(serverPublicKeyJwk);
        const serverPublicKey: CryptoKey = await crypto.subtle.importKey(
            "jwk", 
            serverPublicKeyJwk,
            {
                name: "RSASSA-PKCS1-v1_5",
                hash: "SHA-512"
            },
            true,
            ["verify"]);
        
        return serverPublicKey;
    }

    /** Verify response JWT signature and state using server public key and given this.state
     * @param responseJwt response from server, signed with K_S+
     * @param serverPublicKey server's public key K_S+
     * @returns true if response signature could be verified, false otherwise
     */
    private async verifyResponseSignature(responseJwt: string, serverPublicKey: CryptoKey): Promise<Boolean>{
        let enc = new TextEncoder();

        var jwtParts: string[] = responseJwt.split(".");
        var signatureBase64: string = jwtParts[2];
        var signature: Uint8Array = decodeBase64url(signatureBase64);

        let verified: Boolean = await crypto.subtle.verify(
            "RSASSA-PKCS1-v1_5",
            serverPublicKey,
            signature,
            enc.encode(jwtParts[0]+ "." +jwtParts[1]));

        return verified;
    }

    /** Extract server's DH parameters from server response
     * @param responseJwt
     * @returns server's DH parameters as an array of CryptoKeys
    */
    private async getServerDhParams(body: any): Promise<CryptoKey[]|undefined[]> {
        var serverDhMacJwk = JSON.parse(body["dhMac"]);
        var serverDhEncJwk = JSON.parse(body["dhEnc"]);
        
        var serverDhMac = await crypto.subtle.importKey(
            "jwk",
            serverDhMacJwk,
            {
                name: "ECDH",
                namedCurve: "P-256",
            },
            true,
            ['deriveKey']);

        var serverDhEnc = await crypto.subtle.importKey(
            "jwk",
            serverDhEncJwk,
            {
                name: "ECDH",
                namedCurve: "P-256",
            },
            true,
            ['deriveKey']);

        return [serverDhMac, serverDhEnc];
    }

    /** Parse session response, verify signatures and compute DH secret
     * @param responseJwt response from server containing all relevant session information and workload identity
     * @returns Server's public DH keys (for MAC and enc)
     */
    public async verifyResponse(responseJwt: string): Promise<CryptoKey[]|undefined[]> {
        var jwtParts: string[] = responseJwt.split(".");
        var jwtHeader: string = jwtParts[0];
        var jwtBody: string = jwtParts[1];
        var jwtSignature: string = jwtParts[2];
        var bodyAsJson = JSON.parse(atob(jwtBody));
        const serverPublicKey = await this.verifyWorkloadId(bodyAsJson["workloadId"]);
        if (serverPublicKey) { 
            if (!this.verifyResponseSignature(responseJwt, serverPublicKey)) {
                console.log("Session Response Token could not be verified");
                return [undefined, undefined];
            }
            else {
                console.log("Session Response Token verified");
            }
        }
        else {
            return [undefined, undefined];
        }
        
        if (this.state != bodyAsJson["state"]) {    // returned state is different from local state
            return [undefined, undefined];
        }
        this.state = "";
        const dhServerParams = await this.getServerDhParams(bodyAsJson);
        return dhServerParams;
    }

    /** Derive DH shared secret for HMAC sign/verify
     * @params privateKey
     * @params publicKey
     * @params salt: random ArrayBuffer value with length 32 byte
     * @return DH secret CryptoKey
     */
    public async calcDhMacSecret(privateKey: CryptoKey, publicKey: CryptoKey): Promise<CryptoKey> {
        // Derive a ECDH key which will be used as input to the HKDF alorithm to derive a HMAC key
        const baseKey = await crypto.subtle.deriveKey(
            {
            name: "ECDH",
            public: publicKey,
            },
            privateKey,
            {
            name: "HKDF",
            hash: "SHA-256",
            salt: new ArrayBuffer(0),
            info: new ArrayBuffer(0),
            },
            false,
            ["deriveKey"],
        );
        return await crypto.subtle.deriveKey(
            {
            name: "HKDF",
            hash: "SHA-256",
            salt: new Uint8Array(0),   // omit salt
            info: new Uint8Array(0),
            },
            baseKey,
            {
            name: "HMAC",
            hash: "SHA-256",
            },
            false,
            ["sign", "verify"],
        );
    }

    /** Derive DH shared secret for encrypting/decrypting
     * @params privateKey
     * @params publicKey
     * @return DH secret CryptoKey
     */
    public async calcDhEncSecret(privateKey: CryptoKey, publicKey: CryptoKey): Promise<CryptoKey> {
        return await crypto.subtle.deriveKey(
            {
            name: "ECDH",
            public: publicKey,
            },
            privateKey,
            {
            name: "AES-GCM",
            length: 256,
            },
            false,
            ["encrypt", "decrypt"],
        );
    }

    public getSessionToken(responseJwt: string): string {
        var jwtParts: string[] = responseJwt.split(".");
        var jwtBody: string = jwtParts[1];
        var bodyAsJson = JSON.parse(atob(jwtBody));
    
        return bodyAsJson["sessionToken"];
    }

    public getExp(responseJwt: string): number {
        var jwtParts: string[] = responseJwt.split(".");
        var jwtBody: string = jwtParts[1];
        var bodyAsJson = JSON.parse(atob(jwtBody));
    
        return bodyAsJson["exp"];
    }
}